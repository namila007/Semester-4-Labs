$date
	Tue Sep  5 23:50:57 2017
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module for_processor_test $end
$var wire 3 ! INaddr [2:0] $end
$var wire 8 " Immediate [7:0] $end
$var wire 32 # Instruction_code [31:0] $end
$var wire 8 $ OPCODE [7:0] $end
$var wire 8 % OUT1 [7:0] $end
$var wire 3 & OUT1addr [2:0] $end
$var wire 8 ' OUT2 [7:0] $end
$var wire 3 ( OUT2addr [2:0] $end
$var wire 8 ) RESULT [7:0] $end
$var wire 32 * Read_addr [31:0] $end
$var wire 3 + SELECT [2:0] $end
$var wire 1 , mux1OUT $end
$var wire 8 - mux1out [7:0] $end
$var wire 1 . mux2OUT $end
$var wire 8 / mux2out [7:0] $end
$var wire 8 0 twosComplement [7:0] $end
$var reg 1 1 clk $end
$var reg 1 2 reset $end
$var reg 1 3 reset_reg $end
$scope module c1 $end
$var wire 1 4 clk $end
$var wire 1 5 reset $end
$var reg 32 6 addr [31:0] $end
$upscope $end
$scope module instruct_mem1 $end
$var wire 32 7 Read_addr [31:0] $end
$var reg 32 8 Instruction_code [31:0] $end
$upscope $end
$scope module instruct_reg1 $end
$var wire 3 9 INaddr [2:0] $end
$var wire 8 : Immediate [7:0] $end
$var wire 32 ; Instruction [31:0] $end
$var wire 8 < OPCODE [7:0] $end
$var wire 3 = OUT1addr [2:0] $end
$var wire 3 > OUT2addr [2:0] $end
$var wire 1 4 clk $end
$upscope $end
$scope module cu1 $end
$var wire 3 ? SELECT [2:0] $end
$var wire 8 @ opcode [7:0] $end
$var reg 1 A mulx1 $end
$var reg 1 B mulx2 $end
$upscope $end
$scope module regfile $end
$var wire 8 C IN [7:0] $end
$var wire 3 D INaddr [2:0] $end
$var wire 8 E OUT1 [7:0] $end
$var wire 3 F OUT1addr [2:0] $end
$var wire 8 G OUT2 [7:0] $end
$var wire 3 H OUT2addr [2:0] $end
$var wire 1 4 clk $end
$var reg 9 I reg0 [8:0] $end
$var reg 9 J reg1 [8:0] $end
$var reg 9 K reg2 [8:0] $end
$var reg 9 L reg3 [8:0] $end
$var reg 9 M reg4 [8:0] $end
$var reg 9 N reg5 [8:0] $end
$var reg 9 O reg6 [8:0] $end
$var reg 9 P reg7 [8:0] $end
$upscope $end
$scope module tcmplmnt $end
$var wire 8 Q IN [7:0] $end
$var wire 8 R OUT [7:0] $end
$upscope $end
$scope module mulx2 $end
$var wire 8 S IN1 [7:0] $end
$var wire 8 T IN2 [7:0] $end
$var wire 8 U OUT [7:0] $end
$var wire 1 . SELECT $end
$upscope $end
$scope module mulx1 $end
$var wire 8 V IN1 [7:0] $end
$var wire 8 W IN2 [7:0] $end
$var wire 8 X OUT [7:0] $end
$var wire 1 , SELECT $end
$upscope $end
$scope module alu $end
$var wire 8 Y DATA1 [7:0] $end
$var wire 8 Z DATA2 [7:0] $end
$var wire 3 [ Select [2:0] $end
$var reg 8 \ out [7:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b11111111 \
b0 [
bx Z
b11111111 Y
b11111111 X
bx W
b11111111 V
bx U
bx T
bx S
bx R
bx Q
bx P
bx O
bx N
bx M
bx L
bx K
bx J
bx I
b0 H
bx G
b111 F
bx E
b100 D
b11111111 C
xB
0A
b1000 @
b0 ?
b0 >
b111 =
b1000 <
b1000000001000000000011111111 ;
b11111111 :
b100 9
b1000000001000000000011111111 8
b0 7
b0 6
05
04
03
02
01
bx 0
bx /
x.
b11111111 -
0,
b0 +
b0 *
b11111111 )
b0 (
bx '
b111 &
bx %
b1000 $
b1000000001000000000011111111 #
b11111111 "
b100 !
$end
#10
11
14
#20
b10101010 \
b10101010 )
b10101010 C
b10101010 -
b10101010 X
b10101010 Y
b110 !
b110 9
b110 D
b10101010 "
b10101010 :
b10101010 V
b10 &
b10 =
b10 F
b1000000001100000000010101010 8
b1000000001100000000010101010 #
b1000000001100000000010101010 ;
b11111111 M
b1 6
b1 *
b1 7
01
04
#30
11
14
#40
b10111011 \
b10111011 )
b10111011 C
b10111011 -
b10111011 X
b10111011 Y
b11 !
b11 9
b11 D
b10111011 "
b10111011 :
b10111011 V
b11 &
b11 =
b11 F
b1000000000110000000010111011 8
b1000000000110000000010111011 #
b1000000000110000000010111011 ;
b10 6
b10 *
b10 7
b10101010 O
01
04
#50
11
14
#60
b10111011 /
b10111011 U
b10111011 W
b1000101 0
b1000101 R
b1000101 T
b10111011 %
b10111011 E
b10111011 Q
b10111011 S
b1100101 \
b1100101 )
b1100101 C
b10101010 '
b10101010 G
b10101010 Z
b1 +
b1 ?
b1 [
0B
0.
1A
1,
b10111011 -
b10111011 X
b10111011 Y
b101 !
b101 9
b101 D
b1 $
b1 <
b1 @
b11 "
b11 :
b11 V
b110 (
b110 >
b110 H
b1000001010000011000000011 8
b1000001010000011000000011 #
b1000001010000011000000011 ;
b10111011 L
b11 6
b11 *
b11 7
01
04
#70
11
14
#80
b1100101 -
b1100101 X
b1100101 Y
b1100101 /
b1100101 U
b1100101 W
b11111111 '
b11111111 G
b11111111 Z
b10011011 0
b10011011 R
b10011011 T
b1100101 %
b1100101 E
b1100101 Q
b1100101 S
b1100101 \
b1100101 )
b1100101 C
b10 +
b10 ?
b10 [
b1 !
b1 9
b1 D
b10 $
b10 <
b10 @
b101 "
b101 :
b101 V
b101 &
b101 =
b101 F
b100 (
b100 >
b100 H
b10000000010000010000000101 8
b10000000010000010000000101 #
b10000000010000010000000101 ;
b100 6
b100 *
b100 7
b1100101 N
01
04
#90
11
14
#100
b10101010 -
b10101010 X
b10101010 Y
b10101010 /
b10101010 U
b10101010 W
b1010110 0
b1010110 R
b1010110 T
b10101010 %
b10101010 E
b10101010 Q
b10101010 S
b1100101 '
b1100101 G
b1100101 Z
b11101111 \
b11101111 )
b11101111 C
b11 +
b11 ?
b11 [
b10 !
b10 9
b10 D
b11 $
b11 <
b11 @
b110 "
b110 :
b110 V
b110 &
b110 =
b110 F
b1 (
b1 >
b1 H
b11000000100000000100000110 8
b11000000100000000100000110 #
b11000000100000000100000110 ;
b1100101 J
b101 6
b101 *
b101 7
01
04
#110
11
14
#120
b11101111 -
b11101111 X
b11101111 Y
b11101111 /
b11101111 U
b11101111 W
b10001 0
b10001 R
b10001 T
b11101111 %
b11101111 E
b11101111 Q
b11101111 S
b11101111 \
b11101111 )
b11101111 C
bx '
bx G
bx Z
b0 +
b0 ?
b0 [
b111 !
b111 9
b111 D
b0 $
b0 <
b0 @
b10 "
b10 :
b10 V
b10 &
b10 =
b10 F
b0 (
b0 >
b0 H
b1110000000000000010 8
b1110000000000000010 #
b1110000000000000010 ;
b110 6
b110 *
b110 7
b11101111 K
01
04
#130
11
14
#140
b110100 \
b110100 )
b110100 C
b1000101 0
b1000101 R
b1000101 T
b10111011 %
b10111011 E
b10111011 Q
b10111011 S
b1000101 -
b1000101 X
b1000101 Y
b1000101 /
b1000101 U
b1000101 W
b11101111 '
b11101111 G
b11101111 Z
b1 +
b1 ?
b1 [
1B
1.
b100 !
b100 9
b100 D
b1001 $
b1001 <
b1001 @
b11 "
b11 :
b11 V
b11 &
b11 =
b11 F
b111 (
b111 >
b111 H
b1001000001000000011100000011 8
b1001000001000000011100000011 #
b1001000001000000011100000011 ;
b11101111 P
b111 6
b111 *
b111 7
01
04
#150
11
14
#160
b1000 6
b1000 *
b1000 7
b110100 M
01
04
